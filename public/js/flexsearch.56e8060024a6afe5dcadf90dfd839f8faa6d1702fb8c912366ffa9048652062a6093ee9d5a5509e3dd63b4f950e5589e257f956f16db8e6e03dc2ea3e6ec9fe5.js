(()=>{var se=Object.create;var te=Object.defineProperty;var oe=Object.getOwnPropertyDescriptor;var ae=Object.getOwnPropertyNames;var re=Object.getPrototypeOf,le=Object.prototype.hasOwnProperty;var he=(e,i)=>()=>(i||e((i={exports:{}}).exports,i),i.exports);var ue=(e,i,n,s)=>{if(i&&typeof i=="object"||typeof i=="function")for(let o of ae(i))!le.call(e,o)&&o!==n&&te(e,o,{get:()=>i[o],enumerable:!(s=oe(i,o))||s.enumerable});return e};var ce=(e,i,n)=>(n=e!=null?se(re(e)):{},ue(i||!e||!e.__esModule?te(n,"default",{value:e,enumerable:!0}):n,e));var ie=he((exports,module)=>{(function _f(self){"use strict";try{module&&(self=module)}catch(e){}self._factory=_f;var t;function u(e){return typeof e!="undefined"?e:!0}function aa(e){let i=Array(e);for(let n=0;n<e;n++)i[n]=v();return i}function v(){return Object.create(null)}function ba(e,i){return i.length-e.length}function x(e){return typeof e=="string"}function C(e){return typeof e=="object"}function D(e){return typeof e=="function"}function ca(e,i){var n=da;if(e&&(i&&(e=E(e,i)),this.H&&(e=E(e,this.H)),this.J&&1<e.length&&(e=E(e,this.J)),n||n==="")){if(e=e.split(n),this.filter){i=this.filter,n=e.length;let s=[];for(let o=0,r=0;o<n;o++){let l=e[o];l&&!i[l]&&(s[r++]=l)}e=s}return e}return e}let da=/[\p{Z}\p{S}\p{P}\p{C}]+/u,ea=/[\u0300-\u036f]/g;function fa(e,i){let n=Object.keys(e),s=n.length,o=[],r="",l=0;for(let h=0,f,p;h<s;h++)f=n[h],(p=e[f])?(o[l++]=F(i?"(?!\\b)"+f+"(\\b|_)":f),o[l++]=p):r+=(r?"|":"")+f;return r&&(o[l++]=F(i?"(?!\\b)("+r+")(\\b|_)":"("+r+")"),o[l]=""),o}function E(e,i){for(let n=0,s=i.length;n<s&&(e=e.replace(i[n],i[n+1]),e);n+=2);return e}function F(e){return new RegExp(e,"g")}function ha(e){let i="",n="";for(let s=0,o=e.length,r;s<o;s++)(r=e[s])!==n&&(i+=n=r);return i}var ja={encode:ia,F:!1,G:""};function ia(e){return ca.call(this,(""+e).toLowerCase(),!1)}let ka={},G={};function la(e){I(e,"add"),I(e,"append"),I(e,"search"),I(e,"update"),I(e,"remove")}function I(e,i){e[i+"Async"]=function(){let n=this,s=arguments;var o=s[s.length-1];let r;return D(o)&&(r=o,delete s[s.length-1]),o=new Promise(function(l){setTimeout(function(){n.async=!0;let h=n[i].apply(n,s);n.async=!1,l(h)})}),r?(o.then(r),this):o}}function ma(e,i,n,s){let o=e.length,r=[],l,h,f=0;s&&(s=[]);for(let p=o-1;0<=p;p--){let g=e[p],_=g.length,y=v(),k=!l;for(let m=0;m<_;m++){let w=g[m],q=w.length;if(q)for(let z=0,A,$;z<q;z++)if($=w[z],l){if(l[$]){if(!p){if(n)n--;else if(r[f++]=$,f===i)return r}(p||s)&&(y[$]=1),k=!0}if(s&&(A=(h[$]||0)+1,h[$]=A,A<o)){let R=s[A-2]||(s[A-2]=[]);R[R.length]=$}}else y[$]=1}if(s)l||(h=y);else if(!k)return[];l=y}if(s)for(let p=s.length-1,g,_;0<=p;p--){g=s[p],_=g.length;for(let y=0,k;y<_;y++)if(k=g[y],!l[k]){if(n)n--;else if(r[f++]=k,f===i)return r;l[k]=1}}return r}function na(e,i){let n=v(),s=v(),o=[];for(let r=0;r<e.length;r++)n[e[r]]=1;for(let r=0,l;r<i.length;r++){l=i[r];for(let h=0,f;h<l.length;h++)f=l[h],n[f]&&!s[f]&&(s[f]=1,o[o.length]=f)}return o}function J(e){this.l=e!==!0&&e,this.cache=v(),this.h=[]}function oa(e,i,n){C(e)&&(e=e.query);let s=this.cache.get(e);return s||(s=this.search(e,i,n),this.cache.set(e,s)),s}J.prototype.set=function(e,i){if(!this.cache[e]){var n=this.h.length;for(n===this.l?delete this.cache[this.h[n-1]]:n++,--n;0<n;n--)this.h[n]=this.h[n-1];this.h[0]=e}this.cache[e]=i},J.prototype.get=function(e){let i=this.cache[e];if(this.l&&i&&(e=this.h.indexOf(e))){let n=this.h[e-1];this.h[e-1]=this.h[e],this.h[e]=n}return i};let qa={memory:{charset:"latin:extra",D:3,B:4,m:!1},performance:{D:3,B:3,s:!1,context:{depth:2,D:1}},match:{charset:"latin:extra",G:"reverse"},score:{charset:"latin:advanced",D:20,B:3,context:{depth:3,D:9}},default:{}};function ra(e,i,n,s,o,r,l){setTimeout(function(){let h=e(n?n+"."+s:s,JSON.stringify(l));h&&h.then?h.then(function(){i.export(e,i,n,o,r+1)}):i.export(e,i,n,o,r+1)})}function K(e,i){if(!(this instanceof K))return new K(e);var n;if(e){x(e)?e=qa[e]:(n=e.preset)&&(e=Object.assign({},n[n],e)),n=e.charset;var s=e.lang;x(n)&&(n.indexOf(":")===-1&&(n+=":default"),n=G[n]),x(s)&&(s=ka[s])}else e={};let o,r,l=e.context||{};if(this.encode=e.encode||n&&n.encode||ia,this.register=i||v(),this.D=o=e.resolution||9,this.G=i=n&&n.G||e.tokenize||"strict",this.depth=i==="strict"&&l.depth,this.l=u(l.bidirectional),this.s=r=u(e.optimize),this.m=u(e.fastupdate),this.B=e.minlength||1,this.C=e.boost,this.map=r?aa(o):v(),this.A=o=l.resolution||1,this.h=r?aa(o):v(),this.F=n&&n.F||e.rtl,this.H=(i=e.matcher||s&&s.H)&&fa(i,!1),this.J=(i=e.stemmer||s&&s.J)&&fa(i,!0),n=i=e.filter||s&&s.filter){n=i,s=v();for(let h=0,f=n.length;h<f;h++)s[n[h]]=1;n=s}this.filter=n,this.cache=(i=e.cache)&&new J(i)}t=K.prototype,t.append=function(e,i){return this.add(e,i,!0)},t.add=function(e,i,n,s){if(i&&(e||e===0)){if(!s&&!n&&this.register[e])return this.update(e,i);if(i=this.encode(i),s=i.length){let p=v(),g=v(),_=this.depth,y=this.D;for(let k=0;k<s;k++){let m=i[this.F?s-1-k:k];var o=m.length;if(m&&o>=this.B&&(_||!g[m])){var r=L(y,s,k),l="";switch(this.G){case"full":if(2<o){for(r=0;r<o;r++)for(var h=o;h>r;h--)if(h-r>=this.B){var f=L(y,s,k,o,r);l=m.substring(r,h),M(this,g,l,f,e,n)}break}case"reverse":if(1<o){for(h=o-1;0<h;h--)l=m[h]+l,l.length>=this.B&&M(this,g,l,L(y,s,k,o,h),e,n);l=""}case"forward":if(1<o){for(h=0;h<o;h++)l+=m[h],l.length>=this.B&&M(this,g,l,r,e,n);break}default:if(this.C&&(r=Math.min(r/this.C(i,m,k)|0,y-1)),M(this,g,m,r,e,n),_&&1<s&&k<s-1){for(o=v(),l=this.A,r=m,h=Math.min(_+1,s-k),o[r]=1,f=1;f<h;f++)if((m=i[this.F?s-1-k-f:k+f])&&m.length>=this.B&&!o[m]){o[m]=1;let w=this.l&&m>r;M(this,p,w?r:m,L(l+(s/2>l?0:1),s,k,h-1,f-1),e,n,w?m:r)}}}}}this.m||(this.register[e]=1)}}return this};function L(e,i,n,s,o){return n&&1<e?i+(s||0)<=e?n+(o||0):(e-1)/(i+(s||0))*(n+(o||0))+1|0:0}function M(e,i,n,s,o,r,l){let h=l?e.h:e.map;(!i[n]||l&&!i[n][l])&&(e.s&&(h=h[s]),l?(i=i[n]||(i[n]=v()),i[l]=1,h=h[l]||(h[l]=v())):i[n]=1,h=h[n]||(h[n]=[]),e.s||(h=h[s]||(h[s]=[])),r&&h.includes(o)||(h[h.length]=o,e.m&&(e=e.register[o]||(e.register[o]=[]),e[e.length]=h)))}t.search=function(e,i,n){n||(!i&&C(e)?(n=e,e=n.query):C(i)&&(n=i));let s=[],o,r,l=0;if(n){e=n.query||e,i=n.limit,l=n.offset||0;var h=n.context;r=n.suggest}if(e&&(e=this.encode(""+e),o=e.length,1<o)){n=v();var f=[];for(let g=0,_=0,y;g<o;g++)if((y=e[g])&&y.length>=this.B&&!n[y])if(this.s||r||this.map[y])f[_++]=y,n[y]=1;else return s;e=f,o=e.length}if(!o)return s;i||(i=100),h=this.depth&&1<o&&h!==!1,n=0;let p;h?(p=e[0],n=1):1<o&&e.sort(ba);for(let g,_;n<o;n++){if(_=e[n],h?(g=sa(this,s,r,i,l,o===2,_,p),r&&g===!1&&s.length||(p=_)):g=sa(this,s,r,i,l,o===1,_),g)return g;if(r&&n===o-1){if(f=s.length,!f){if(h){h=0,n=-1;continue}return s}if(f===1)return ta(s[0],i,l)}}return ma(s,i,l,r)};function sa(e,i,n,s,o,r,l,h){let f=[],p=h?e.h:e.map;if(e.s||(p=ua(p,l,h,e.l)),p){let g=0,_=Math.min(p.length,h?e.A:e.D);for(let y=0,k=0,m,w;y<_&&!((m=p[y])&&(e.s&&(m=ua(m,l,h,e.l)),o&&m&&r&&(w=m.length,w<=o?(o-=w,m=null):(m=m.slice(o),o=0)),m&&(f[g++]=m,r&&(k+=m.length,k>=s))));y++);if(g){if(r)return ta(f,s,0);i[i.length]=f;return}}return!n&&f}function ta(e,i,n){return e=e.length===1?e[0]:[].concat.apply([],e),n||e.length>i?e.slice(n,n+i):e}function ua(e,i,n,s){return n?(s=s&&i>n,e=(e=e[s?i:n])&&e[s?n:i]):e=e[i],e}t.contain=function(e){return!!this.register[e]},t.update=function(e,i){return this.remove(e).add(e,i)},t.remove=function(e,i){let n=this.register[e];if(n){if(this.m)for(let s=0,o;s<n.length;s++)o=n[s],o.splice(o.indexOf(e),1);else N(this.map,e,this.D,this.s),this.depth&&N(this.h,e,this.A,this.s);if(i||delete this.register[e],this.cache){i=this.cache;for(let s=0,o,r;s<i.h.length;s++)r=i.h[s],o=i.cache[r],o.includes(e)&&(i.h.splice(s--,1),delete i.cache[r])}}return this};function N(e,i,n,s,o){let r=0;if(e.constructor===Array)if(o)i=e.indexOf(i),i!==-1?1<e.length&&(e.splice(i,1),r++):r++;else{o=Math.min(e.length,n);for(let l=0,h;l<o;l++)(h=e[l])&&(r=N(h,i,n,s,o),s||r||delete e[l])}else for(let l in e)(r=N(e[l],i,n,s,o))||delete e[l];return r}t.searchCache=oa,t.export=function(e,i,n,s,o){let r,l;switch(o||(o=0)){case 0:if(r="reg",this.m){l=v();for(let h in this.register)l[h]=1}else l=this.register;break;case 1:r="cfg",l={doc:0,opt:this.s?1:0};break;case 2:r="map",l=this.map;break;case 3:r="ctx",l=this.h;break;default:return}return ra(e,i||this,n,r,s,o,l),!0},t.import=function(e,i){if(i)switch(x(i)&&(i=JSON.parse(i)),e){case"cfg":this.s=!!i.opt;break;case"reg":this.m=!1,this.register=i;break;case"map":this.map=i;break;case"ctx":this.h=i}},la(K.prototype);function va(e){e=e.data;var i=self._index;let n=e.args;var s=e.task;switch(s){case"init":s=e.options||{},e=e.factory,i=s.encode,s.cache=!1,i&&i.indexOf("function")===0&&(s.encode=Function("return "+i)()),e?(Function("return "+e)()(self),self._index=new self.FlexSearch.Index(s),delete self.FlexSearch):self._index=new K(s);break;default:e=e.id,i=i[s].apply(i,n),postMessage(s==="search"?{id:e,msg:i}:{id:e})}}let wa=0;function O(e){if(!(this instanceof O))return new O(e);var i;e?D(i=e.encode)&&(e.encode=i.toString()):e={},(i=(self||window)._factory)&&(i=i.toString());let n=typeof window=="undefined"&&self.exports,s=this;this.o=xa(i,n,e.worker),this.h=v(),this.o&&(n?this.o.on("message",function(o){s.h[o.id](o.msg),delete s.h[o.id]}):this.o.onmessage=function(o){o=o.data,s.h[o.id](o.msg),delete s.h[o.id]},this.o.postMessage({task:"init",factory:i,options:e}))}P("add"),P("append"),P("search"),P("update"),P("remove");function P(e){O.prototype[e]=O.prototype[e+"Async"]=function(){let i=this,n=[].slice.call(arguments);var s=n[n.length-1];let o;return D(s)&&(o=s,n.splice(n.length-1,1)),s=new Promise(function(r){setTimeout(function(){i.h[++wa]=r,i.o.postMessage({task:e,id:wa,args:n})})}),o?(s.then(o),this):s}}function xa(a,b,c){let d;try{d=b?eval('new (require("worker_threads")["Worker"])("../dist/node/node.js")'):a?new Worker(URL.createObjectURL(new Blob(["onmessage="+va.toString()],{type:"text/javascript"}))):new Worker(x(c)?c:"worker/worker.js",{type:"module"})}catch(e){}return d}function Q(e){if(!(this instanceof Q))return new Q(e);var i=e.document||e.doc||e,n;this.K=[],this.h=[],this.A=[],this.register=v(),this.key=(n=i.key||i.id)&&S(n,this.A)||"id",this.m=u(e.fastupdate),this.C=(n=i.store)&&n!==!0&&[],this.store=n&&v(),this.I=(n=i.tag)&&S(n,this.A),this.l=n&&v(),this.cache=(n=e.cache)&&new J(n),e.cache=!1,this.o=e.worker,this.async=!1,n=v();let s=i.index||i.field||i;x(s)&&(s=[s]);for(let o=0,r,l;o<s.length;o++)r=s[o],x(r)||(l=r,r=r.field),l=C(l)?Object.assign({},e,l):e,this.o&&(n[r]=new O(l),n[r].o||(this.o=!1)),this.o||(n[r]=new K(l,this.register)),this.K[o]=S(r,this.A),this.h[o]=r;if(this.C)for(e=i.store,x(e)&&(e=[e]),i=0;i<e.length;i++)this.C[i]=S(e[i],this.A);this.index=n}function S(e,i){let n=e.split(":"),s=0;for(let o=0;o<n.length;o++)e=n[o],0<=e.indexOf("[]")&&(e=e.substring(0,e.length-2))&&(i[s]=!0),e&&(n[s++]=e);return s<n.length&&(n.length=s),1<s?n:n[0]}function T(e,i){if(x(i))e=e[i];else for(let n=0;e&&n<i.length;n++)e=e[i[n]];return e}function U(e,i,n,s,o){if(e=e[o],s===n.length-1)i[o]=e;else if(e)if(e.constructor===Array)for(i=i[o]=Array(e.length),o=0;o<e.length;o++)U(e,i,n,s,o);else i=i[o]||(i[o]=v()),o=n[++s],U(e,i,n,s,o)}function V(e,i,n,s,o,r,l,h){if(e=e[l])if(s===i.length-1){if(e.constructor===Array){if(n[s]){for(i=0;i<e.length;i++)o.add(r,e[i],!0,!0);return}e=e.join(" ")}o.add(r,e,h,!0)}else if(e.constructor===Array)for(l=0;l<e.length;l++)V(e,i,n,s,o,r,l,h);else l=i[++s],V(e,i,n,s,o,r,l,h)}t=Q.prototype,t.add=function(e,i,n){if(C(e)&&(i=e,e=T(i,this.key)),i&&(e||e===0)){if(!n&&this.register[e])return this.update(e,i);for(let s=0,o,r;s<this.h.length;s++)r=this.h[s],o=this.K[s],x(o)&&(o=[o]),V(i,o,this.A,0,this.index[r],e,o[0],n);if(this.I){let s=T(i,this.I),o=v();x(s)&&(s=[s]);for(let r=0,l,h;r<s.length;r++)if(l=s[r],!o[l]&&(o[l]=1,h=this.l[l]||(this.l[l]=[]),!n||!h.includes(e))&&(h[h.length]=e,this.m)){let f=this.register[e]||(this.register[e]=[]);f[f.length]=h}}if(this.store&&(!n||!this.store[e])){let s;if(this.C){s=v();for(let o=0,r;o<this.C.length;o++)r=this.C[o],x(r)?s[r]=i[r]:U(i,s,r,0,r[0])}this.store[e]=s||i}}return this},t.append=function(e,i){return this.add(e,i,!0)},t.update=function(e,i){return this.remove(e).add(e,i)},t.remove=function(e){if(C(e)&&(e=T(e,this.key)),this.register[e]){for(var i=0;i<this.h.length&&(this.index[this.h[i]].remove(e,!this.o),!this.m);i++);if(this.I&&!this.m)for(let n in this.l){i=this.l[n];let s=i.indexOf(e);s!==-1&&(1<i.length?i.splice(s,1):delete this.l[n])}this.store&&delete this.store[e],delete this.register[e]}return this},t.search=function(e,i,n,s){n||(!i&&C(e)?(n=e,e=""):C(i)&&(n=i,i=0));let o=[],r=[],l,h,f,p,g,_,y=0;if(n)if(n.constructor===Array)f=n,n=null;else{if(e=n.query||e,f=(l=n.pluck)||n.index||n.field,p=n.tag,h=this.store&&n.enrich,g=n.bool==="and",i=n.limit||i||100,_=n.offset||0,p&&(x(p)&&(p=[p]),!e)){for(let m=0,w;m<p.length;m++)(w=ya.call(this,p[m],i,_,h))&&(o[o.length]=w,y++);return y?o:[]}x(f)&&(f=[f])}f||(f=this.h),g=g&&(1<f.length||p&&1<p.length);let k=!s&&(this.o||this.async)&&[];for(let m=0,w,q,z;m<f.length;m++){let A;if(q=f[m],x(q)||(A=q,q=A.field,e=A.query||e,i=A.limit||i),k)k[m]=this.index[q].searchAsync(e,i,A||n);else{if(s?w=s[m]:w=this.index[q].search(e,i,A||n),z=w&&w.length,p&&z){let $=[],R=0;g&&($[0]=[w]);for(let X=0,ee,B;X<p.length;X++)ee=p[X],(z=(B=this.l[ee])&&B.length)&&(R++,$[$.length]=g?[B]:B);R&&(w=g?ma($,i||100,_||0):na(w,$),z=w.length)}if(z)r[y]=q,o[y++]=w;else if(g)return[]}}if(k){let m=this;return new Promise(function(w){Promise.all(k).then(function(q){w(m.search(e,i,n,q))})})}if(!y)return[];if(l&&(!h||!this.store))return o[0];for(let m=0,w;m<r.length;m++){if(w=o[m],w.length&&h&&(w=za.call(this,w)),l)return w;o[m]={field:r[m],result:w}}return o};function ya(e,i,n,s){let o=this.l[e],r=o&&o.length-n;if(r&&0<r)return(r>i||n)&&(o=o.slice(n,n+i)),s&&(o=za.call(this,o)),{tag:e,result:o}}function za(e){let i=Array(e.length);for(let n=0,s;n<e.length;n++)s=e[n],i[n]={id:s,doc:this.store[s]};return i}t.contain=function(e){return!!this.register[e]},t.get=function(e){return this.store[e]},t.set=function(e,i){return this.store[e]=i,this},t.searchCache=oa,t.export=function(e,i,n,s,o){if(o||(o=0),s||(s=0),s<this.h.length){let r=this.h[s],l=this.index[r];i=this,setTimeout(function(){l.export(e,i,o?r:"",s,o++)||(s++,o=1,i.export(e,i,r,s,o))})}else{let r,l;switch(o){case 1:r="tag",l=this.l;break;case 2:r="store",l=this.store;break;default:return}ra(e,this,n,r,s,o,l)}},t.import=function(e,i){if(i)switch(x(i)&&(i=JSON.parse(i)),e){case"tag":this.l=i;break;case"reg":this.m=!1,this.register=i;for(let s=0,o;s<this.h.length;s++)o=this.index[this.h[s]],o.register=i,o.m=!1;break;case"store":this.store=i;break;default:e=e.split(".");let n=e[0];e=e[1],n&&e&&this.index[n].import(e,i)}},la(Q.prototype);var Ba={encode:Aa,F:!1,G:""};let Ca=[F("[\xE0\xE1\xE2\xE3\xE4\xE5]"),"a",F("[\xE8\xE9\xEA\xEB]"),"e",F("[\xEC\xED\xEE\xEF]"),"i",F("[\xF2\xF3\xF4\xF5\xF6\u0151]"),"o",F("[\xF9\xFA\xFB\xFC\u0171]"),"u",F("[\xFD\u0177\xFF]"),"y",F("\xF1"),"n",F("[\xE7c]"),"k",F("\xDF"),"s",F(" & ")," and "];function Aa(e){var i=e=""+e;return i.normalize&&(i=i.normalize("NFD").replace(ea,"")),ca.call(this,i.toLowerCase(),!e.normalize&&Ca)}var Ea={encode:Da,F:!1,G:"strict"};let Fa=/[^a-z0-9]+/,Ga={b:"p",v:"f",w:"f",z:"s",x:"s",\u00DF:"s",d:"t",n:"m",c:"k",g:"k",j:"k",q:"k",i:"e",y:"e",u:"o"};function Da(e){e=Aa.call(this,e).join(" ");let i=[];if(e){let n=e.split(Fa),s=n.length;for(let o=0,r,l=0;o<s;o++)if((e=n[o])&&(!this.filter||!this.filter[e])){r=e[0];let h=Ga[r]||r,f=h;for(let p=1;p<e.length;p++){r=e[p];let g=Ga[r]||r;g&&g!==f&&(h+=g,f=g)}i[l++]=h}}return i}var Ia={encode:Ha,F:!1,G:""};let Ja=[F("ae"),"a",F("oe"),"o",F("sh"),"s",F("th"),"t",F("ph"),"f",F("pf"),"f",F("(?![aeo])h(?![aeo])"),"",F("(?!^[aeo])h(?!^[aeo])"),""];function Ha(e,i){return e&&(e=Da.call(this,e).join(" "),2<e.length&&(e=E(e,Ja)),i||(1<e.length&&(e=ha(e)),e&&(e=e.split(" ")))),e||[]}var La={encode:Ka,F:!1,G:""};let Ma=F("(?!\\b)[aeo]");function Ka(e){return e&&(e=Ha.call(this,e,!0),1<e.length&&(e=e.replace(Ma,"")),1<e.length&&(e=ha(e)),e&&(e=e.split(" "))),e||[]}G["latin:default"]=ja,G["latin:simple"]=Ba,G["latin:balance"]=Ea,G["latin:advanced"]=Ia,G["latin:extra"]=La;let W=self,Y,Z={Index:K,Document:Q,Worker:O,registerCharset:function(e,i){G[e]=i},registerLanguage:function(e,i){ka[e]=i}};(Y=W.define)&&Y.amd?Y([],function(){return Z}):W.exports?W.exports=Z:W.FlexSearch=Z})(exports)});var ne=ce(ie());var H=document.getElementById("search__text"),j=document.getElementById("search__suggestions");H!==null&&document.addEventListener("keydown",e=>{e.ctrlKey&&e.key==="/"?(e.preventDefault(),H.focus()):e.key==="Escape"&&(H.blur(),j.classList.add("search__suggestions--hidden"))});document.addEventListener("click",e=>{j.contains(e.target)||j.classList.add("search__suggestions--hidden")});document.addEventListener("keydown",e=>{if(j.classList.contains("search__suggestions--hidden"))return;let n=[...j.querySelectorAll("a")];if(n.length===0)return;let s=n.indexOf(document.activeElement);if(e.key==="ArrowDown"){e.preventDefault();let o=s+1<n.length?s+1:s;n[o].focus()}else e.key==="ArrowUp"&&(e.preventDefault(),nextIndex=s>0?s-1:0,n[nextIndex].focus())});(function(){let e=new ne.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/tutorials/a-different-way-to-think-about-recursion/",title:"A Different Way to Think About Recursion",description:"Recursions can be hard to understand. In this article, I am proposing a different way of thinking to make it easier to construct and work with recursive functions",content:` In order to understand recursion you must first understand recursion
If you are in a hurry, you can skip directly to the summary section.
Recursion is a simple but very confusing concept. When I first learned about it, I was confused as to how a function can call itself. I was working on some code the other day, and I had to use recursion to solve a problem, and while I was writing the function, I had a realization that changed how I look at recursion. I would like to share that with you here today.
First, let&rsquo;s start with a brief explanation of what recursion is, in case it is new to you. If you already know what it is, you can skip to the next section.
What is recursion?# Recursion is a programming concept that arises from the Functional Programming paradigm. The world of functional programming is built on a few key principles:
minimal to no mutation of external states. Everything that a function does must be contained within itself, with no side effects. This means a function should only rely on its inputs to generate its outputs and not manipulate any external variables or entities, including their inputs, unless absolutely necessary. Functions must be deterministic. Given the same inputs, the same outputs should be expected. This is because there are no side effects, as mentioned above. All functions must return something. Functions have inputs and produce outputs, and since there should not be any side effects, the best way to know the output of a function is to read the function&rsquo;s return values. A function that adheres to the first two principals is known as a pure function. Pure functions are stateless in design because they do not rely on or manipulate external states. Ok, so with those core pillars of functional programming in mind, we can tackle recursion. To answer the main question, here is my simple definition of recursion:
Recursion is when a function calls itself with different inputs until a base case is reached. It&rsquo;s not a perfect definition, but it captures everything that is needed for our purposes today. A recursive function, if written correctly, is an example of a pure function. It takes some input, iterates over it, produces some output, and does not mutate any external states. Recursive functions must also have a return value, or they will continue forever. In the case of Python, you would reach the maximum allowed recursion depth.
Factorial Example# A simple example of a recursive function is a factorial calculator function:
def factorial(n:int) -&gt; int: if n == 1: return 1 return n * factorial(n-1) A factorial is a product of all integers from 1 up to a limit $n$, like this: $$n \\times (n-1) \\times (n-2) \\times ..\\times (n-(n-1))$$
The function does exactly this. It takes an integer $n$ and multiplies it by the value returned by calling the function again with the value below\xA0$n$. The base case in this case is when we reach $1$ which is $n-(n-1)$. At this point, we know we have gone through all the values from where we started.
The Rethinking# When I learned about recursion, I was both confused and mesmerized by what I was looking at. Imagine being given a task, and instead of doing all of it by yourself, you spawn a clone of yourself to handle a part of it, and the clone does the same, each new clone handling smaller and smaller parts of the task. I wanted to use it everywhere but found it very tricky to implement. Clones are very slippery things to mess with.
It was not until today, when I was tackling a classic recursion problem of tree traversal, that I reflected on what was actually going on. I had always had a hard time figuring out what the base case was and how to represent it in the function, together with the information I would need to pass to the function on the recursive call.
I thought about what was happening and came to this conclusion:
Recursion is about simplifying inputs going forward and clarifying going backwards.
If a light bulb doesn&rsquo;t immediately go explode in your head, I hope it will by the end of the article. Let&rsquo;s look at that factorial description again: $$N \\times (N-1 \\times (N-2 \\times &hellip;. (N-(N-1))))$$
Whether you use $PEMDAS$ or $BODMAS$, the same thing always comes first in the order of operations: parenthesis. Therefore, if we were to evaluate the expression for a factorial, we would have to start from the right towards the left. Basically, start at the end and work our way back to the beginning.
Corporate Structure Example# Imagine that the investors of a large tech company want a status report for the whole company. The board calls a meeting of the different leaders of the company, like the CFO and CTO, and each member is tasked with generating reports for their part of the company. The CTO calls the departmental managers below him and asks for a similar report, but only for the technology side, and the senior managers go to the junior manager, and they go to the team leaders below them and ask for the same thing. Lastly, each team member reports to their team leader about what they are working on and the status of the projects.
The team members are at the bottom of the chain and have the actual information. They don&rsquo;t need to ask anyone else below them and are the &ldquo;base case&rdquo;. So now each team member gives a report, which the team leader compiles together with a report of their own activities and sends it up to the managers. The managers compile all reports from the teams they manage and add information about their office before pushing it up. This goes on until we finally get back to the board, which then compiles all this information and gives it to the investors. The investors can then decide how many private jets they should get for their spouses.
At each level going down, the information requested gets simpler and simpler relative to the complexity of a large company. The person requesting the information at each stage has some level of uncertainty because they may not know the details of what is happening within each node below them. On the way up, the person at each node is able to piece together the information returned from each node to form a clear picture of what is going on and pass it on to the person above. Code Example# When we no longer have any more uncertainty about what information the function should return, we have reached the bottom of the tree, the core of the nesting, the base case. From here, it is about compiling the information going up. Each stage provides more and more certainty to the caller. Now the tricky part is deciding how to &lsquo;compile&rsquo; this information and what information is uncertain and needs to be clarified by a &rsquo;lesser&rsquo; function call. So going down the recursion stack trace, we are simplifying the input, and going up, we are providing clarification and reducing uncertainty. To go back to the factorial, we see that at each stage, we are unsure of what the total product of the numbers that come before is. So we simplify the input by taking away the current value of $N$ in each recursive call until we have certainty that the product of 1 and itself is 1.
Let&rsquo;s take a look at a small example similar to the problem I was tackling when I came to this realization. We have a directory structure that looks like this:
{ &#34;Documents&#34;: { &#34;Proposal.docx&#34;: None, &#34;Report&#34;: {&#34;AnnualReport.pdf&#34;: None, &#34;Financials.xlsx&#34;: None}, }, &#34;Downloads&#34;: {&#34;picture1.jpg&#34;: None, &#34;picture2.jpg&#34;: None}, }\xA0We need to generate an array of all file path strings after walking them. You know you have reached the end of a file path when you encounter a key that has a value of None. A key is considered a directory if it has a dict as a value. Here is an example of how to solve the problem in Python.
def list_files(current_node, current_path=&#34;&#34;): file_list = [] for k, v in current_node.items(): if v != None: file_list.extend(list_files(v, f&#34;{current_path}/{k}&#34;))\xA0else: file_list.append(f&#34;{current_path}/{k}&#34;) return file_list For each node (directory) we encounter, we do not know which files, if any, are contained in each of the nodes within. This is uncertainty. We know all the files that are in the current node but not below, so we call the function again for sub-node sub-node within the current node. We simplify the input and call the function again.
Eventually, we get to a place with no uncertainty and also to the point at which we cannot make the input any smaller or simpler without breaking things. At this point, we have reached the base case. From here, we begin returning values, and each value we return builds on other values that were returned from other nodes or the calling node. All the way up to the genesis node.
Summary# If you are no longer in such a hurry, jump back to the top
The key takeaway from this article is recursion is about simplifying inputs going forward and clarifying going backwards. Which briefly means:
If you want to write a good recursive function, you should aim to make it a pure and deterministic function. It should only take the inputs it requires and not make any mutations to external states. If you are struggling to come up with the structure, think of the final recursive call and imagine the simplest form of the input that has absolute certainty. Make that your base case. In the case of the factorial, it was n==1 was the simplest form of n whose factors we know about. In the case of the directory traversal, it was v==None. Build upon that base case to determine how you can simplify the inputs for each round. Make it such that the return value for each round of recursion is a absolute version of what was given to as input. Conclusion# I hope this article helped change how you look at recursion for the better and that you will now be able to write recursive factions with confidence and make fewer mistakes.
Thank you for reading. You can reach out for comments, corrections and compliments via email, or on twitter.
`}).add({id:1,href:"/tutorials/recursively-convert-django-model-to-dict/",title:"How to Recursively Convert Django Model to Dict",description:"In this article we will look at how to create your own recursive serializer in Django without using the Django Rest Framework Sometimes when working with Django, we may have some data that we want to serialize (convert to JSON) but we do not have the option of using the serializers that come with Django Rest Framework. The data can also take the same form for many cases and writing a new serializer for all of those cases can be tedious and repetitive.",content:`In this article we will look at how to create your own recursive serializer in Django without using the Django Rest Framework Sometimes when working with Django, we may have some data that we want to serialize (convert to JSON) but we do not have the option of using the serializers that come with Django Rest Framework. The data can also take the same form for many cases and writing a new serializer for all of those cases can be tedious and repetitive. This sounds like something a utility function that can be used to generalize the logic and be reused where needed, hence this article&rsquo;s existence.
By the end of the article, we should have a utility function like this:
import json from somewhere import ModelFoo from utilities import generic_serializer instances = ModelFoo.objects.filter(some_filter) serialized_instances = generic_serializer(instance, i_fields=[&#39;bar&#39;], i_models=[&#39;baz&#39;]) with open(&#39;Foo_data.json&#39;, &#39;w&#39;) as fd: json.dump(serialized_instances, fd, default=str, indent=2) Defining the models# To explain things better, let us use an example. Suppose we have a Django application that stores data for a chain of car dealerships. Each dealership has cars that customers go to one of them to buy a car. The example models.py is shown below:
# models.py from django.db import models class Dealership(models.Model): name = models.CharField(max_length=20) street_name = models.CharField(max_length=20) zip_code = models.CharField(max_length=6) def __str__(self): return self.name class Car(models.Model): name = models.CharField(max_length=20) brand = models.CharField(max_length=20) year = models.CharField(max_length=20) price = models.DecimalField(max_digits=7, decimal_places=2) dealership = models.ForeignKey(Dealership, on_delete=models.CASCADE) def __str__(self): return f&#34;{self.name} {self.brand}&#34; Creating the generic serializer# Finding the fields# To start us off the first thing our serializer need to be able to do to create a dict of the fields and values of our given model instance. In this article, we will focus on the Car model instance and try to serialize it. To give us something to work with we create some sample instances:
# backups.py dealership = Dealership.objects.create(name=&#34;LopezCars&#34;, street_name=&#34;Tarmac&#34;, zip_code=&#34;90210&#34;) # {&#34;id&#34;:1, &#34;name&#34;:&#34;LopezCars&#34;, &#34;street_name&#34;: &#34;Tarmac&#34;, &#34;zip_code&#34;: &#34;90210&#34;} car = Car.objects.create(name=&#34;Cami\xF3n &#34;, brand=&#34;Suave&#34;, year=&#34;2020&#34;, price=&#34;2283&#34;, dealership=1) # {&#34;id&#34;:1, &#34;name&#34;:&#34;Cami\xF3n&#34;, &#34;brand&#34;:&#34;Suave&#34;, &#34;year&#34;:&#34;2020&#34;, &#34;price&#34;:Decimal(&#39;2283.00&#39;), &#34;dealership&#34;: 1} The simplest way to convert a model instance to a dict in django is to use the model_to_dict function that is built into django. To use it, simply import it and pass a model instance to it. It supports include all or exclude all but the specified fields.
&gt;&gt;&gt; from django.forms import model_to_dict &gt;&gt;&gt; from .backups import car &gt;&gt;&gt; &gt;&gt;&gt; model_to_dict(car) &gt;&gt;&gt; {&#34;name&#34;:&#34;Cami\xF3n&#34;, &#34;model&#34;:&#34;Suave&#34;, &#34;year&#34;:&#34;2020&#34;, &#34;price&#34;:Decimal(&#39;2283.00&#39;), &#34;dealership&#34;: 1} &gt;&gt;&gt; &gt;&gt;&gt; model_to_dict(car, fields=[&#34;brand&#34;, &#34;price&#34;]) &gt;&gt;&gt; {&#34;model&#34;:&#34;Suave&#34;, &#34;price&#34;:Decimal(&#39;2283.00&#39;)} &gt;&gt;&gt; &gt;&gt;&gt; model_to_dict(car, exclude=[&#34;brand&#34;, &#34;price&#34;]) &gt;&gt;&gt; {&#34;name&#34;:&#34;Cami\xF3n&#34;, &#34;year&#34;:&#34;2020&#34;, &#34;dealership&#34;: 1} While model_to_dict is very useful for a simple model, it is not powerful enough for what we may need, like recursively fetching related models. Django models have the _meta API which is an instance an django.db.models.options.Options object that allows us to fetch all the field instances of a model. One of the properties available in _meta is the fields which is a django.utils.datastructures.ImmutableList.
We can use this list to get all fields and construct a dict object out of it like so:
# backups.py ... fields = {} for f in car._meta.fields: fields[f.name] = getattr(model, f.name) # if you wish to use a comprehension: fields = {f.name: getattr(model, f.name) for f in car._meta.fields} # {&#34;id&#34;:1, &#34;name&#34;:&#34;Cami\xF3n&#34;, &#34;brand&#34;:&#34;Suave&#34;, &#34;year&#34;:&#34;2020&#34;, &#34;price&#34;:Decimal(&#39;2283.00&#39;), &#34;dealership&#34;: &lt;Dealership: LopezCars&gt; } Looking at the output, you may notice that with this method, we preserve the object Primary Key (id) a.k.a pk and the dealership is not just the id. If we do the same thing for dealership:
# backups.py ... # if you wish to use a comprehension: fields = {f.name: getattr(model, f.name) for f in dealership._meta.fields} # {&#34;id&#34;:1, &#34;name&#34;:&#34;LopezCars&#34;, &#34;street_name&#34;: &#34;Tarmac&#34;, &#34;zip_code&#34;: &#34;90210&#34;} And now we combine the two:
# backups.py fields = {f.name: getattr(model, f.name) for f in car._meta.fields} fields[&#39;dealership&#39;] = {f.name: getattr(model, f.name) for f in dealership._meta.fields} # {&#34;id&#34;:1, &#34;name&#34;:&#34;Cami\xF3n&#34;, &#34;brand&#34;:&#34;Suave&#34;, &#34;year&#34;:&#34;2020&#34;, &#34;price&#34;:Decimal(&#39;2283.00&#39;), &#34;dealership&#34;: {&#34;id&#34;:1, &#34;name&#34;:&#34;LopezCars&#34;, &#34;street_name&#34;: &#34;Tarmac&#34;, &#34;zip_code&#34;: &#34;90210&#34;}} We have successfully converted the model into a dictionary. This is nice, but it is specific to car so to make it generic using the magic of recursion:
# utilities.py from django.db.models import Model def get_fields(model: models.Model, fields: dict = None) -&gt; dict: if not fields: fields = {} for f in model._meta.fields: fields[f.name] = getattr(model, f.name) for name, value in fields.items(): if not isinstance(value, model.Model): # skip non-relational (ForeignKey) fields continue fields[name] = getattr(value, &#34;pk&#34;) if name in ignore_models else get_fields(value) return fields get_fields(car) # {&#34;id&#34;:1, &#34;name&#34;:&#34;Cami\xF3n&#34;, &#34;brand&#34;:&#34;Suave&#34;, &#34;year&#34;:&#34;2020&#34;, &#34;price&#34;:Decimal(&#39;2283.00&#39;), &#34;dealership&#34;: {&#34;id&#34;:1, &#34;name&#34;:&#34;LopezCars&#34;, &#34;street_name&#34;: &#34;Tarmac&#34;, &#34;zip_code&#34;: &#34;90210&#34;}} Now we have a generic function to transform any model into a dict object and that can recurse into the other models within it. If that is all you needed, then you can stop here. We have made a slightly more powerful version of model_to_dict.
Extra Functionality# The get_fields function is fine the way it is and is perfectly usable now. But what if we don&rsquo;t need the to see the brand field or maybe dealership related model? If we want to get information for more than one car we would have to run the function on both of them. To achieve these things we need to expand it with a few things.
# utilities.py from django.db.models import Model def generic_serializer( instances: list, exclude_models: list = None, exclude_fields: list = None, ) -&gt; list: def get_fields(model: Model = None, fields: dict = None) -&gt; dict: if not fields: fields = {} for f in model._meta.fields: if ( not f.is_relation and f.name in exclude_fields ): continue fields[f.name] = getattr(model, f.name) for name, value in fields.items(): if not isinstance(value, Model): continue # Replace the excluded related model field with their primary key value # Instead of storing the \`model.__str__()\` value, it shows the model.pk # if it is in \`exclude_models\` fields[name] = getattr(value, &#34;pk&#34;) if name in exclude_models else get_fields(value) return fields return [get_fields(instance) for instance in instances] To check if a field f is a relation field i.e models.ForeignKey field, we can use f.is_relation. For the car model the dealership field is a relational field to Dealership models. Therefor, the value for for dealership.is_relation is True. This allows the exclusion of non-relation field in exclude_field without excluding a relation field with the same name and vice versa. The line if not is instance(value, Model) checks if there there are any relation fields to trigger a recursion.
We are done! (^O^)/ It is a simple function, but it is very useful.
Thanks for taking the time to read this article and I hope it has been useful to you.
`}).add({id:2,href:"/tutorials/create-custom-permission-class-in-django/",title:"How to Create Custom Permission Class in Django",description:`Permissions can be a hustle to deal with when developing an api. Suppose we have a number of api views and endpoints where the access permissions are very similar to one another with only slight variations..
We could create different permission classes with the slight changes that fit the specific endpoint&rsquo;s needs. That works, but that involves a lot of repetition and duplicated code that can be hard to update later down the line.`,content:`Permissions can be a hustle to deal with when developing an api. Suppose we have a number of api views and endpoints where the access permissions are very similar to one another with only slight variations..
We could create different permission classes with the slight changes that fit the specific endpoint&rsquo;s needs. That works, but that involves a lot of repetition and duplicated code that can be hard to update later down the line.
This is where an abstract or generic permission class comes in handy. We can define template permissions and logic that can be inherited and extended by child permission classes or the modified in the ViewSet class like so:
# views.py from somewhere import AbstractPermission class MyViewSet(viewsets.ModelViewSet): serializer_class = MySerializer permission_classes = (AbstractPermission,) deny_action = { &#34;CLIENT&#34;: (&#34;create&#34;,) } Defining our structure# To get started, we can have an example project for CozyCoin Bank with branches in different countries. Each branch has one manager, several clerks, and marketers. CozyCoin customers are rich and can also have multiple bank accounts. Below are our simple models. I have only included fields necessary for explanations. All the user models inherit from a default user model class were the common fields for all users are defined. For our specific case, we are using the roles field to specify which group the user falls under, but you can use django groups if you wish. I find assigning roles much easier to manage.
# models.py ... ... class User(AbstractBaseUser): class Roles(models.TextChoices): MANAGER = &#34;MANAGER&#34;, &#34;Manager&#34; SUPPORT = &#34;SUPPORT&#34;, &#34;Support&#34; CLERK = &#34;CLERK&#34;, &#34;Clerk&#34; CUSTOMER = &#34;CUSTOMER&#34;, &#34;Customer&#34; class BankBranch(models.Model): manager = models.ForeignKey(Manager, on_delete=models.CASCADE) class Customer(User): role = models.CharField(max_length=20, default=User.Roles.CUSTOMER. class Manager(User): role = models.CharField(max_length=20, default=User.Roles.MANAGER. class Clerk(User): role = models.CharField(max_length=20, default=User.Roles.CLERK. class Support(User): role = models.CharField(max_length=20, default=User.Roles.SUPPORT. class Account(models.Model): customer = models.ForeignKey(Customer, on_delete=models.CASCADE) bank_branch = models.ForeignKey(Bank, on_delete=models.CASCADE) class Transactions(models.Model): account = models.ForeignKey(Account, on_delete=models.CASCADE) ... ... Let&rsquo;s assume that the serializers and views have also been setup with a sample viewset looking like this:
# views.py class SomeModelViewSet(viewsets.ModelViewSet): serializer_class = SomeModelSerializer permission_classes = (SomePermissionClass,) # this is the important part def get_queryset(self): # your queryset logic here pass Creating the abstract permission class# A basic permission class# In order to determine if a user has permissions depending on their role, we first have to create an abstract permission class that inherits from rest framework&rsquo;s BasePermission. We will deny any anonymous request since we require the user to be logged in to view their role. If you don&rsquo;t have an account of any sort with CozyCoin, then you shouldn&rsquo;t have access to anything protected by these permissions.
# permissions.py from rest_framework import permissions class IsRole(permissions.BasePermission): def has_permission(self, request, view): if request.user.is_anonymous: return Fals. def has_object_permission(self, request, view, obj): pass For our permissions to be effective, we first have to determine if the user making the request is in the desired group. The role property is initialized to None and is supposed to be modified in the child classes. If it is not, then SomeErroris raised. SomeError being an error of your choosing. This will ensure that the permissions don&rsquo;t silently fail and deny all requests since the role will always be None and therefor not match any roles.
# permissions.py class IsRole(permissions.BasePermission): role = None def has_permission(self, request, view): if request.user.is_anonymous: return Fals. return self.has_role(request): def has_object_permission(self, request, view, obj): return self.has_role(request) def has_role(self, request)-&gt; bool: if self.role == None: raise SomeError return request.user.role == self.role And that&rsquo;s it! We can create child classes that specify the roles we want to grant access to. For example:
# views.py from some_location.permissions import IsRole class IsCustomer(IsRole): role = &#34;CUSTOMER&#34; class CustomerOnlyView(viewsets.ViewSet): permission_classes = (IsCustomer,) ... Granting only the owner of an object permissions# The permissions we have defined above are perfectly usable, but if you are keen you might have noticed a problem. Taking the IsCustomer permissions for example, if the request user is not a customer they will be blocked just fine. The problem is the customer can request for any customer data that is not theirs and it will be granted to them. This means that any customer can view any other customer&rsquo;s data in a view protected by these permissions. To help with this issue, we need to tweak our has_object_permission method.
# permissions.py ... ... def has_object_permission(self, request, view, obj): owner = getattr(obj, self.role.lower()) return owner.id == request.user.id With this small tweak, instead of just giving any data to anyone so long as they have a certain role, we will be able to only limit th.
data to what they own or is linked to them. This assumes that the foreign key field pointing to the user table is named the same as the role but in all lowercase. This means that if the role is CLIENT, then the foreign key field in the model is called client. An alternative it to get the name of the fields to check at runtime instead of relying on the role name which could be different.
# permissions class IsRole(permissions.BasePermission): owner_field = None ... def has_object_permission(self, request, view, obj): user = getattr(obj, self.owner_field or self.role.lower())) return user.id == request.user.id . class IsCustomer(IsRole): role = &#34;CUSTOMER&#34; owner_field = &#34;client&#34; Granting privileged users access# Wait, what if the person asking for the data has higher access rights like an admin or us? We don&rsquo;t want to make the managers feel less powerful. We have different ways we can deal with this problem. How you approach it will depend on what you named your abstract class and how abstract you want to go. The first approach is to use a variable that grants a set of user roles access. In this example, we can name the field allow_staff.
class IsRole(permissions.BasePermission): allow_staff = False staff_roles = [&#34;ADMIN&#34;, &#34;MANAGER&#34;] ... def has_permission(self, request, view, obj): ... if self.allow_staff and request.user.role in staff_roles: return True ... def has_object_permission(self, request, view, obj): if self.allow_staff and request.user.role in staff_roles: return True ... With this approach, we can define the staff_roles and set allow_staff to true to give the people with staff_roles access. If we want to go even more abstract then we can use the second approach were we can define allow_roles instead of staff_roles. With this we don&rsquo;t need to check if allow_staff is true or not, we just check if the current user role is one of the special ones.
Grant access by view action# Now, that we can filter permissions by roles, we can also try filtering by the action being performed. For example we might not want a support staff member should not be able to view all the customers and their data in one place at once. (This is only useful with a non-incremental system object ID. There&rsquo;s nothing stopping Joe from going up the number of client IDs from one in an incremental system). We might want them to only have access to the specific client asking for support and only for a short period of time or after they have been per-approved by a client issue ticket handling system. Also when Bob from marketing wants to send an email to all customers over 35, who look like they could use a loan, he will need not any permissions to modify customer data. So we will give him and his team read only access.
To achieve this, we can add it another attribute deny_actions to the abstract class. This attribute can be a list containing actions we want to deny on that endpoint. We can then check for the list in the has_permission method:
# permissions.py ... if self.deny_actions and view.action not in self.deny_actions: return True This solution is simple, but it will also deny any special privileged users from performing the actions. We can change it up slightly by making deny_actions accept a dictionary with the user roles as the keys and denied roles as the values. e.g:
deny_actions = { &#34;MARKETING&#34;: [&#34;create&#34;, &#34;update&#34;, &#34;delete&#34;] } We can put the logic for that in a separate class method and only call it when we need to. We also raise an exception in case the values are not formatted correctly.
# permissions.py ... ... def is_action_denied(self, request, view): if isinstance(self.deny_actions, dict): actions = self.deny_actions.get(request.user.role) elif isinstance(self.deny_actions, list | tuple): actions = self.deny_actions else: raise TypeError( f&#34;Invalid type {type(self.deny_actions)} for deny_actions. Expected iterable&#34; ) if actions and view.action in actions: return False return True Getting values from the view# Sometimes you do not want to create an entire class just so you can change 1 value and use it on one view only. What would be point of doing all this work? We just need to have a bit more code and logic.
# permissions.py deny_actions = None allow_roles = None allow_staff = None def has_permission(self, request, view): deny_actions = getattr(view, &#39;deny_actions&#39;, None) allow_roles = getattr(view, &#39;allow_roles&#39;, None) allow_staff = getattr(view, &#39;allow_staff&#39;, None) This will allow us to specify the extra values when creating the child permission classes or within the view like so:
# views.py class SomeModelViewSet(viewsets.ModelViewSet): serializer_class = SomeModelSerializer permission_classes = (IsClient,) allow_staff = True deny_actions = { &#34;MANAGER&#34;: [&#34;create&#34;, &#34;update&#34;, &#34;delete&#34;] } def get_queryset(self): pass The part where we fetch the filters can also bring up a problem if you have many of them, or if we increase the filters in the future. So we define a method that is called by has_permissions method before doing anything.
# permissions.py ... def get_or_set_attributes(self, request, view): for attribute in dir(self): if not attribute.startswith(&#34;_&#34;): # ignore any magic methods and private variables value = getattr(self, attribute) if value == None: setattr(self, attribute, getattr(view, attribute, None)) Limitations# So this method of creating things an abstract permissions class is very useful. It means we only have to make a few changes to existing and that&rsquo;s it. If we need new very specific permissions, we don&rsquo;t have to duplicate some code from somewhere and only change a few things to fit the view. There are some issues with this approach.
Too much code in one place.
As we are trying to make the abstract class as versatile and flexible as possible, we have to cram so much logic and checks in it. This can very quickly become a nightmare to maintain or to read back in 6 months.
Long setup time.
It took me quite a while to come up with the class and logic. It works well for the most part, but it might be hard to adapt it to a different application. Is it worth the time it took to make it? \xAF_(\u30C4)_/\xAF Maybe it will be in the long run as I would just copy paste the class into other projects, and instantly get customizable permissions without defining them once again.
Reliance on role.
If you were to remove the role attribute, major parts of the class will have to be redone or rethought. With this structure, a user can only belong to one role. This limitation could be overcome by allowing the primary search field to be set in child class or in the viewset.
Limited extensibility.
There is only so much you can add before it becomes a too much. The best thing at that point would be to create a separate abstract permission class.
This only works class based views. I have not created or tested a function based view version of this code, so it might not work for that use case
Conclusion# Thanks for getting to the end. Whether you got here by reading or scrolling or copy pasting. You can find the full permission class on github gits
`}).add({id:3,href:"/tutorials/data-structures-and-altorithms/algorithms/",title:"Algorithms",description:`SEARCH ALGORITHMS# Linear Search# Linear search goes over all elements and checks if it is the target element.
Since the search has to go through all elements in the worst case where there the values is not there, it has a complexity of $O(n)$.
// golang package search func Linear(items []int, target int) bool { for _, n := range items { if n == target { return true } } return false } Binary Search# Binary search is used to find items in an ordered list by iteratively halving the input.`,content:`SEARCH ALGORITHMS# Linear Search# Linear search goes over all elements and checks if it is the target element.
Since the search has to go through all elements in the worst case where there the values is not there, it has a complexity of $O(n)$.
// golang package search func Linear(items []int, target int) bool { for _, n := range items { if n == target { return true } } return false } Binary Search# Binary search is used to find items in an ordered list by iteratively halving the input. For each iteration we check the half that satisfies the bounding conditions of the search target and break it until we find the target or the target is not in the given input.
The bounds condition is usually $L \\le T \\lt U$ where $L=upper\\ limit$ ,$\\ T=target$ and $U=Upper\\ limit$. The $U$ and $L$ are determined by the sorting order. So for example, if the items are sorted in alphabetical order, and a target $T$, the the first break will be $([A - M], [N - Z])$. Since $T$ is between $N$ and $Z$, we break the second list for the next search.
The index $M$ of the middle value is determined by:
$$ M = \\left\\lfloor \\frac{(L + (U-L))}{2} \\right\\rfloor $$
The values for the lower and upper limits change depending on which of the 2 halves fit the conditions where we expect to find the target.
//golang func Binary(items []int, target int) bool { upper := len(items) ascending := items[0] &lt; items[upper-1] // incase we have a reversed array lower := 0 middle := 0 for { middle = lower + (upper-lower)/2 if middle == len(items)-1 { return items[middle] == target } if middle == lower { return items[middle] == target } middleValue := items[middle] if middleValue == target { return true } if ascending { if target &lt; middleValue { upper = middle } else if middleValue &lt; target { lower = middle + 1 } } else { if target &lt; middleValue { lower = middle + 1 } else { upper = middle } } } } With this implementation, we initialize upper bounds to be the length of the input and lower and middle to 0. The first condition to check is if we are at the end of the array. If array is sorted in ascending order and we are searching for a value that happens to be at the end, the search will tend to move towards the right and eventually get to the last element. We don&rsquo;t want to search beyond that otherwise an index out of range will be raised at items[middle].
For every value of middle, we check if the value at the index matches our target and return true if it is. The next condition can be tricky but to understand, but I think it helps to only use the less than &lt; or greater than &gt; checks only instead of both. I prefer less than because it is easier to visualize the target either being on the left or on the right, and &lsquo;discarding&rsquo; the rest.
If we have the first 10 values of the fibonacci sequence as our array: items = [0, 1, 1, 2, 5, 8, 13, 21, 34, 55]. We have this:
The middle value determines will become the new upper or lower depending on if it comes before or after target in the less than expression. i.e., if it comes after, then we discard all that is beyond it. If it comes before the target, then we discard all before it including itself.
If we complete the computation, for this list and do some clever ordering, you we can get the following graph AS you can see from the graph, the more items we have in the array, the the curve tends towards a flatness. For every iteration of the loop, the total search pool is halved, and so is the time that it would take to complete the search. Therefore, this algorithm has a complexity of $O(log\\ n)$.
SORTING ALGORITHMS# A sorted array $X$ is mathematically defined as $X_i\\lt X_{i+1}$ where $i$ is any index within list lower than the maximum i.e. $0 \\le i \\lt len(X)$
Bubble Sort# In order to do a bubble sort, we traverse the entire array and move compare each 2 consecutive values and check if the above condition is true. Swap their positions if they are not.
So if we have an array:
pi = [3, 1, 4, 1, 5] we can sort them as below: With each iteration, the largest values always get pushed to the end of the array, and thus, in the worst case, each iteration will doing 1 less check than the last iteration. Therefor the number of elements to to check for each iteration goes down with the following the following progression:
iter 1 = N iter 2 = N-1 iter 3 = N-2 . . . iter Last = N-N+1 To get the total number of checks, we simply get a sum of all checks in the iterations. In our example, we have 5 elements, and the number of checks per iteration are:
5 + 4 + 3 + 2 + 1 The sum of all numbers in up to $K$:
$$ \\Sigma_{n=1}^k = \\frac{n(n + 1)}{2} = O\\left(\\frac{n(n + 1)}{2} \\right) $$
According to the first rule of Big O, we ignore all constants, so the: $\\frac{1}{2}$ can be ignored and we are left with:
$$ O(n^2 + n) $$
In the face of $n^2$, $\\ + n$ is insignificant, so it can be dropped as well according to rule 2, leaving is with a complexity of $O(n^2)$
Here is an implementation of bubble sort in code:
// golang package sort func Bubble(items []int) []int { last_item := len(items) - 1 for range items{ for i, v := range items { if i == last_item { break } if items[i] &gt;= items[i+1] { items[i] = items[i+1] items[i+1] = v } } last_item -= 1 } return items } Recursion# Recursion in programming calling a function within the same function. A function that calls itself is said to be recursive. Each recursion must have a base case where the the recursion will stop, otherwise it will go on ad infinitum or until compute resources are depleted.
A recursive function also needs a return value to pass back to itself for the next call. If the base case is reached, then the function will return a different value and not the function call of itself.
`}).add({id:4,href:"/tutorials/data-structures-and-altorithms/data-structures/",title:"Data Structures",description:`A data structure is a way of representing data in a program, and storing it in memory. There are many structures with their pros and cons, and uses cases. In these notes, we are going to go through some of them and look at how they function and when to use them.
Static Array# Arrays are a contiguous (non-breaking) space in memory with an index for each byte of memory.`,content:`A data structure is a way of representing data in a program, and storing it in memory. There are many structures with their pros and cons, and uses cases. In these notes, we are going to go through some of them and look at how they function and when to use them.
Static Array# Arrays are a contiguous (non-breaking) space in memory with an index for each byte of memory.
Search# If the index of the target element is already known, then retrieving that item is a constant time operation, i.e. $O(1)$ However, if the index of the element is unknown, then we would have to walk the entire array, up until the index of the target element. Fetching from array therefor has $O(n)$ time complexity.
Insertion# To insert into an array, the value at the address is overwritten and the array size remains constant. Inserting into the middle of an array while maintaining data integrity, i.e. not overwriting, involves shifting all elements on position to the right, and inserting the element at the new blank spot. This means for a worst case non-overwriting insertion, we would have to shift $N$ elements for an array of length $N+1$ in order to insert at the beginning of the array. So the time complexity for this type of insertion is $O(n)$
Deletion# Deletion sets the value at the address to an agreed upon value meaning &ldquo;Null&rdquo;, i.e. zero 0. An array&rsquo;s length cannot be decreased. If we want to ensure the indices of elements match what is expected after a deletion, all elements to the right of the deletion have to be shifted one position to the left. This is an $(n)$ in the worst case scenario.
Use Case# Arrays are basic data structures and can therefor be used in almost any situation, but they are mostly preferred where the items to be stored are few and is easy to know the index of the item you are looking for during an operation.
// static array in go var items = [5]int{1,2,3,4,5} Dynamic Array# A dynamic array is a type of array that appears to grow with the number of elements. They do not have a fixed length like a static array.
Search# A dynamic array is just a static array under the hood, so all search operations are the same as a static array.
Insertion# When a dynamic array is instantiated, it is created with slightly more space than is required. So if we create a dynamic array and store 4 elements in it, the underlying array can have 7 memory spaces instead of 4. This way if you were to append or push to the array, it will happen in constant time, because there is still space for 3 more elements in the array.
If we were to add 4 more elements, to the array, a new array with even more space, say 10, is created and all the previous elements are copied to the new array and the new elements are added to the new array instead. The process of copying over the elements can be assumed to be a constant time operation, and therefor ignored when estimating complexity. Therefor the insert operation with growing array is considered constant time complexity. To insert in between elements, the shifting of all necessary elements has to happen, so the time complexity is $O(n)$
Deletion# To delete elements, pop operations are constant time and shift operations are linear time. Dynamic arrays seldom shrink, so the memory allocation remains the same after a deletion.
Use case# Dynamic arrays are the primary form of arrays used in many programming languages under the hood. Static arrays are useful when you know size of the data and all you are sure it will not grow. They provide better memory efficiency. Dynamic arrays are better for when the size of the data is unknown at time of creation. They take up more memory for the same number of elements, but they provide flexibility with size.
// dynamic array (slice) in go var items = []int{1,2,3,4,5} Linked Lists# Link lists are a type of node based data structure. A linked list is a collection of nodes that each contain a value, and a reference to another node.
When each node only has it&rsquo;s value and a reference to one other node, the list is considered a Singly Linked List. As there is only a reference for the next node, we can only traverse the list in one direction and never in reverse.
In most cases, a doubly linked list is used. I.e. a list where the nodes contain the references to the next and previous node in the list.
Search# Since linked lists have no indices, and to get to one node, you need to go through all th preceding nodes that point to it, we have to traverse the list to find what we are looking for. In the worst case, we may have to go through N-1 nodes to find what we are looking for. This gives a complexity of $O(n)$.
Insertion# In order to insert a node $D$ into a doubly linked list $A \\leftrightharpoons B \\leftrightharpoons C$, we need to identify the 2 nodes $A$ and $B$ between which we will insert he new node $D$. We next pointer in $A$ to point to $D$ and set the previous pointer on $D$ to point $A$. We then change the previous pointer in $B$ to point to $D$ and set the next pointer in $D$ to $B$
At the end of all operations, the new list will become $A \\leftrightharpoons D \\leftrightharpoons B \\leftrightharpoons C$.
Setting the values for previous and next is a constant time operation, so $O(1)$ because we are setting 2 previous and 2 next pointer values, we will be perform 4 operations, i.e. $O(4)$, which according to the rules of Big-O, is considered $O(1)$. However, this is only true if we already know where we are inserting to. If we have to search for the insertion point, then we would have to do a linear search which would have a complexity of $O(n)$. Appending and prepending are a constant time operation, because we already know where the insertion point is.
Deletion# In order to delete a node, we can perform the insertion operation, but in reverse. So if we want to delete $B$ from the array $A \\leftrightharpoons D \\leftrightharpoons B \\leftrightharpoons C$ , we set next of $D$ to next of $B$ which is $C$ and remove the next of $B$. We then set previous of $C$ to previous of $C$ and remove previous of $B$. This will leave us with $A \\leftrightharpoons D \\leftrightharpoons C$. Since the operations are practically the same as insertion, the time complexity is still $O(1)$, but just like insertion, deletion complexity is subject if we have to find the deletion point first.
Use Case# A linked list, is a very good data structure to use for a queue. A queue is a first-in-first-out data structure, where items are appended at the tail and used as well as removed at the head. In queues, the head and tail nodes are the most important which means there is little to no need to find an node in the middle of the list. The following is an implementation of a singly-linked list as queue in Golang:
// Singly linked list implementation in form of a queue in go package queue type Node struct { Value interface{} Next *Node } type Queue struct { Name string Size int head *Node tail *Node } func (q *Queue) Enqueue(n *Node) { if q.head == nil { q.head = n q.tail = n // if head is empty, then so is tail } else { q.tail.Next = n } q.tail = n q.Size += 1 } func (q *Queue) Deque() *Node { if q.head == nil { q.tail = nil return nil } dequedNode := q.head // store the current head value before reassigning it q.head = q.head.Next q.Size -= 1 return dequedNode } func (q *Queue) PeekHead() *Node { return q.head } func (q *Queue) PeekTail() *Node { return q.tail } Stack# A stack is a the opposite of a singly-linked list (queue) where the head is at the tail and vice versa. Unlike the FIFO nature of a queue, a stack is First-In-Last-Out. This means we are going to append to and remove from the head. In the diagram below, notice the pointers are going in the reverse direction compared to singly-linked lists Search# Since stacks are FILO, we only need to get the node at the beginning of it. To know what is at the top of the stack, we can use a head to store a pointer to the first node. This is a constant time operation
Insert (push)# To insert a node, all we need to do set the new node&rsquo;s previous pointer to the item pointed to by head, and then set the head pointer to the new node. Deletion (pop)# To delete a node from a stack, we do the reverse of insertion: Take the node at the beginning of the stack and make the value it points to the new head, and remove it&rsquo;s pointer.
`}).add({id:5,href:"/tutorials/data-structures-and-altorithms/big-o-notiation/",title:"Big-O Complexity Notation",description:`Big O complexity notation is used to give a general idea of the performance of an algorithm in terms of resources such as time or memory as the input grows larger. It is not a measure of true performance and is only a guide. The differences between the various algorithms are only seen on really large inputs.
The notation uses the syntax $O(v)$ where $v$ is an expression of complexity. d`,content:`Big O complexity notation is used to give a general idea of the performance of an algorithm in terms of resources such as time or memory as the input grows larger. It is not a measure of true performance and is only a guide. The differences between the various algorithms are only seen on really large inputs.
The notation uses the syntax $O(v)$ where $v$ is an expression of complexity. d
General rules for Big-O notation are:
Always ignore constants. This means $O(2n)$ and $O(\\frac{1}{2}n)$ can be simplified to $O(n)$. Insignificant figures are ignored. So if you have $O(n^2\\times\\frac{n}{2})$ it is equivalent to $O(n^2)$ since $\\frac{n}{2}$ is too small to have in impact Examples of complexity for input size $n$ s are:
$O(1)$
Indicates constant time where the execution time does not change with changing input size $O(n)$
Indicates linear time where the execution time changes proportionally to the input size $O(log \\ n)$
Indicates that the execution time goes down logarithmically with input size. This is usually seen in algorithms where the iterative inputs are reduced to a smaller fraction of the previous input. $O(n\\ log \\ n)$
Same as $O(log \\ n)$ but the but by a magnitude $n$ $O(n^k)$
Indicates exponential growth of magnitude $k$ $O(n!)$ This is also an exponential grown but by the factorial on $n$ which is almost non-computable at certain values of $n$ Big O Algorithms `}),H.addEventListener("input",function(){let n=this.value,s=e.search(n,5,{enrich:!0}),o=new Map;for(let r of s.flatMap(l=>l.result))o.has(r.href)||o.set(r.doc.href,r.doc);if(j.innerHTML="",j.classList.remove("search__suggestions--hidden"),o.size===0&&n){let r=document.createElement("div");r.innerHTML=`No results for "<strong>${n}</strong>"`,r.classList.add("search__no-results"),j.appendChild(r);return}for(let[r,l]of o){let h=document.createElement("a");h.href=r,h.classList.add("search__suggestion-item"),j.appendChild(h);let f=document.createElement("div");f.textContent=l.title,f.classList.add("search__suggestion-title"),h.appendChild(f);let p=document.createElement("div");if(p.textContent=l.description,p.classList.add("search__suggestion-description"),h.appendChild(p),j.childElementCount===5)break}})})();})();
//! Source: https://github.com/h-enk/doks/blob/master/assets/js/index.js
/*! Source: https://dev.to/shubhamprakash/trap-focus-using-javascript-6a3 */
//! Source: https://discourse.gohugo.io/t/range-length-or-last-element/3803/2
